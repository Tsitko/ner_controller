# Правила разработки проекта

## Правила Проектирования

1. Все зависимости строго следуют снизу вверх.
2. Все конфигурации строго на уровне классов, которые их импортируют, в папке `configs/`.
3. Один файл — один класс.
4. Наследование через интерфейсы.

## Правила Тестирования

1. Модульные и интеграционные тесты на каждом уровне проекта в папке `tests`.
2. Все классы покрыты модульными тестами.
3. Все взаимодействия между классами (если один класс импортирует другие) покрыты интеграционными тестами на том уровне, где находится импортирующий класс.
4. Как минимум один интеграционный тест для каждого варианта использования на верхнем уровне проекта.
5. Для каждого use case в проекте должен быть тест, который проверяет полный кейс e2e.

## Правила документирования

1. После каждого изменения в коде, необходимо обновить README.md файлы в соответствующих папках.
2. Readme.md файл в корне проекта должен быть человеко-читаемым и содержать информацию о проекте, его модулях, зависимостях и других важных деталях. Так же он должен содержать информацию о том, как запустить проект, как протестировать его и другие важные детали.
3. В каждой папке должны быть Readme для llm в формате templates/readme_template.md.
4. В корне проекта должен быть обзорный llm_readme.md для llm в формате templates/llm_readme_template.md.

## Правила именования

1. Имена классов должны быть существительными в PascalCase и отражать их назначение.
2. Имена функций и методов должны быть глаголами в camelCase/snake_case (в зависимости от языка) и описывать действие.
3. Имена переменных должны быть существительными в camelCase/snake_case и быть понятными без дополнительных комментариев.
4. Имена констант должны быть в UPPER_SNAKE_CASE.
5. Имена файлов должны соответствовать именам классов/модулей, которые они содержат.
6. Имена папок должны быть в lowercase с подчеркиваниями или дефисами и отражать их назначение.

## Правила стиля кода

1. Всё файлы долджны содержать только utf-8 encoding.
2. Все файлы должны содержать doc strings.
3. Все файлы должны следовать единому стилю форматирования (использовать линтеры и форматтеры).
4. Максимальная длина строки кода — 100-120 символов.
5. Функции и методы не должны превышать 50 строк кода. Если превышают — необходимо разбить на более мелкие функции.
6. Классы не должны превышать 300 строк кода. Если превышают — необходимо рассмотреть возможность разделения на несколько классов.
7. Избегать глубокой вложенности (максимум 3-4 уровня).
8. Использовать явные имена вместо магических чисел и строк.
9. Удалять неиспользуемый код и комментарии.

## Правила обработки ошибок

1. Все ошибки должны быть обработаны явно, не допускается "тихое" игнорирование ошибок.
2. Использовать специфичные типы исключений вместо общих.
3. Логировать все ошибки с достаточным контекстом для отладки.
4. Пользовательские ошибки должны быть понятными и информативными.
5. Критические ошибки должны прерывать выполнение, некритические — обрабатываться с fallback-логикой.

## Правила управления зависимостями

1. Все внешние зависимости должны быть зафиксированы в файлах зависимостей (requirements.txt, package.json, pom.xml и т.д.) с указанием версий.
2. Зависимости должны быть минимально необходимыми — избегать избыточных библиотек.
3. Регулярно обновлять зависимости для исправления уязвимостей безопасности.
4. Использовать зависимости только из проверенных источников (официальные репозитории).
5. Зависимости между модулями проекта должны быть явными и документированными.

## Правила безопасности

1. Не хранить секреты (пароли, ключи API, токены) в коде или в системе контроля версий.
2. Использовать переменные окружения или менеджеры секретов для конфиденциальных данных.
3. Валидировать и санитизировать все пользовательские входные данные.
4. Использовать параметризованные запросы для работы с базами данных.
5. Регулярно проверять зависимости на известные уязвимости безопасности.

## Правила производительности

1. Избегать преждевременной оптимизации, но учитывать производительность при проектировании.
2. Использовать кэширование для часто запрашиваемых данных.
3. Оптимизировать запросы к базе данных (индексы, избегать N+1 проблем).
4. Использовать асинхронные операции для I/O-операций, где это возможно.
5. Профилировать код перед оптимизацией для выявления реальных узких мест.

## Правила работы с Git

1. Коммиты должны быть атомарными и логически завершенными.
2. Сообщения коммитов должны быть понятными и описывать что и зачем изменено.
3. Использовать ветки для разработки новых функций и исправления ошибок.
4. Перед коммитом запускать тесты и проверки линтера.
5. Не коммитить временные файлы, файлы сборки, логи и личные настройки IDE.

## Правила рефакторинга

1. Рефакторинг должен выполняться отдельными коммитами, не смешиваясь с новой функциональностью.
2. Перед рефакторингом необходимо убедиться, что все тесты проходят.
3. После рефакторинга все тесты должны продолжать проходить.
4. Рефакторинг должен улучшать читаемость и поддерживаемость кода без изменения функциональности.
5. Документировать значительные изменения архитектуры после рефакторинга.

## Правила code review

1. Все изменения кода должны проходить code review перед слиянием в основную ветку.
2. Code review должен проверять соответствие правилам проекта, качество кода и покрытие тестами.
3. Комментарии в code review должны быть конструктивными и конкретными.
4. Автор изменений должен отвечать на все комментарии перед слиянием.
5. Минимум один одобряющий review требуется для слияния изменений.

## Правила развертывания

1. Все изменения должны проходить через тестовое окружение перед развертыванием в продакшн.
2. Использовать автоматизированные процессы развертывания (CI/CD).
3. Версионировать релизы согласно семантическому версионированию (SemVer).
4. Ведение changelog для всех значительных изменений.
5. Иметь план отката (rollback) для каждого развертывания.